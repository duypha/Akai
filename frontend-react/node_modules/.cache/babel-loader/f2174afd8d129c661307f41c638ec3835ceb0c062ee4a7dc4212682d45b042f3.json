{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nexport function useVoice(sessionId) {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const resolveRef = useRef(null);\n  const startRecording = useCallback(async () => {\n    try {\n      setError(null);\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n      audioChunksRef.current = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = async () => {\n        stream.getTracks().forEach(track => track.stop());\n        if (audioChunksRef.current.length === 0) {\n          var _resolveRef$current;\n          (_resolveRef$current = resolveRef.current) === null || _resolveRef$current === void 0 ? void 0 : _resolveRef$current.call(resolveRef, null);\n          return;\n        }\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/webm'\n        });\n        if (!sessionId) {\n          var _resolveRef$current2;\n          (_resolveRef$current2 = resolveRef.current) === null || _resolveRef$current2 === void 0 ? void 0 : _resolveRef$current2.call(resolveRef, null);\n          return;\n        }\n        setIsProcessing(true);\n        try {\n          var _resolveRef$current3;\n          const formData = new FormData();\n          formData.append('audio', audioBlob, 'recording.webm');\n          formData.append('session_id', sessionId);\n          const response = await fetch('/api/voice/transcribe', {\n            method: 'POST',\n            body: formData\n          });\n          if (!response.ok) throw new Error('Transcription failed');\n          const data = await response.json();\n          (_resolveRef$current3 = resolveRef.current) === null || _resolveRef$current3 === void 0 ? void 0 : _resolveRef$current3.call(resolveRef, data.transcript);\n        } catch (err) {\n          var _resolveRef$current4;\n          setError(err instanceof Error ? err.message : 'Transcription failed');\n          (_resolveRef$current4 = resolveRef.current) === null || _resolveRef$current4 === void 0 ? void 0 : _resolveRef$current4.call(resolveRef, null);\n        } finally {\n          setIsProcessing(false);\n        }\n      };\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (err) {\n      if (err instanceof Error && err.name === 'NotAllowedError') {\n        setError('Microphone permission denied');\n      } else {\n        setError('Could not access microphone');\n      }\n    }\n  }, [sessionId]);\n  const stopRecording = useCallback(async () => {\n    return new Promise(resolve => {\n      resolveRef.current = resolve;\n      if (mediaRecorderRef.current && isRecording) {\n        setIsRecording(false);\n        mediaRecorderRef.current.stop();\n      } else {\n        resolve(null);\n      }\n    });\n  }, [isRecording]);\n  const speak = useCallback(text => {\n    if (!('speechSynthesis' in window)) return;\n    window.speechSynthesis.cancel();\n\n    // Clean text\n    const cleanText = text.replace(/```[\\s\\S]*?```/g, '').replace(/`[^`]*`/g, '').replace(/[#*_~]/g, '').trim();\n    if (!cleanText) return;\n    const utterance = new SpeechSynthesisUtterance(cleanText);\n    utterance.rate = 1.0;\n    utterance.pitch = 1.0;\n    utterance.volume = 1.0;\n\n    // Try to use a natural voice\n    const voices = window.speechSynthesis.getVoices();\n    const preferredVoice = voices.find(v => v.name.includes('Samantha') || v.name.includes('Google') || v.name.includes('Natural'));\n    if (preferredVoice) {\n      utterance.voice = preferredVoice;\n    }\n    window.speechSynthesis.speak(utterance);\n  }, []);\n  const stopSpeaking = useCallback(() => {\n    if ('speechSynthesis' in window) {\n      window.speechSynthesis.cancel();\n    }\n  }, []);\n  return {\n    isRecording,\n    isProcessing,\n    error,\n    startRecording,\n    stopRecording,\n    speak,\n    stopSpeaking\n  };\n}\n_s(useVoice, \"oUYMBaJv6DlmOfczvliCbgAkeg4=\");","map":{"version":3,"names":["useState","useCallback","useRef","useVoice","sessionId","_s","isRecording","setIsRecording","isProcessing","setIsProcessing","error","setError","mediaRecorderRef","audioChunksRef","resolveRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","mimeType","current","ondataavailable","event","data","size","push","onstop","getTracks","forEach","track","stop","length","_resolveRef$current","call","audioBlob","Blob","type","_resolveRef$current2","_resolveRef$current3","formData","FormData","append","response","fetch","method","body","ok","Error","json","transcript","err","_resolveRef$current4","message","start","name","stopRecording","Promise","resolve","speak","text","window","speechSynthesis","cancel","cleanText","replace","trim","utterance","SpeechSynthesisUtterance","rate","pitch","volume","voices","getVoices","preferredVoice","find","v","includes","voice","stopSpeaking"],"sources":["C:/Users/anhdu/Projects/it-support-agent/frontend-react/src/hooks/useVoice.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\r\n\r\ninterface UseVoiceReturn {\r\n  isRecording: boolean;\r\n  isProcessing: boolean;\r\n  error: string | null;\r\n  startRecording: () => Promise<void>;\r\n  stopRecording: () => Promise<string | null>;\r\n  speak: (text: string) => void;\r\n  stopSpeaking: () => void;\r\n}\r\n\r\nexport function useVoice(sessionId: string | null): UseVoiceReturn {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [isProcessing, setIsProcessing] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n  const audioChunksRef = useRef<Blob[]>([]);\r\n  const resolveRef = useRef<((value: string | null) => void) | null>(null);\r\n\r\n  const startRecording = useCallback(async () => {\r\n    try {\r\n      setError(null);\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType: 'audio/webm;codecs=opus'\r\n      });\r\n\r\n      audioChunksRef.current = [];\r\n\r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          audioChunksRef.current.push(event.data);\r\n        }\r\n      };\r\n\r\n      mediaRecorder.onstop = async () => {\r\n        stream.getTracks().forEach(track => track.stop());\r\n\r\n        if (audioChunksRef.current.length === 0) {\r\n          resolveRef.current?.(null);\r\n          return;\r\n        }\r\n\r\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n\r\n        if (!sessionId) {\r\n          resolveRef.current?.(null);\r\n          return;\r\n        }\r\n\r\n        setIsProcessing(true);\r\n\r\n        try {\r\n          const formData = new FormData();\r\n          formData.append('audio', audioBlob, 'recording.webm');\r\n          formData.append('session_id', sessionId);\r\n\r\n          const response = await fetch('/api/voice/transcribe', {\r\n            method: 'POST',\r\n            body: formData\r\n          });\r\n\r\n          if (!response.ok) throw new Error('Transcription failed');\r\n\r\n          const data = await response.json();\r\n          resolveRef.current?.(data.transcript);\r\n        } catch (err) {\r\n          setError(err instanceof Error ? err.message : 'Transcription failed');\r\n          resolveRef.current?.(null);\r\n        } finally {\r\n          setIsProcessing(false);\r\n        }\r\n      };\r\n\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      mediaRecorder.start();\r\n      setIsRecording(true);\r\n\r\n    } catch (err) {\r\n      if (err instanceof Error && err.name === 'NotAllowedError') {\r\n        setError('Microphone permission denied');\r\n      } else {\r\n        setError('Could not access microphone');\r\n      }\r\n    }\r\n  }, [sessionId]);\r\n\r\n  const stopRecording = useCallback(async (): Promise<string | null> => {\r\n    return new Promise((resolve) => {\r\n      resolveRef.current = resolve;\r\n\r\n      if (mediaRecorderRef.current && isRecording) {\r\n        setIsRecording(false);\r\n        mediaRecorderRef.current.stop();\r\n      } else {\r\n        resolve(null);\r\n      }\r\n    });\r\n  }, [isRecording]);\r\n\r\n  const speak = useCallback((text: string) => {\r\n    if (!('speechSynthesis' in window)) return;\r\n\r\n    window.speechSynthesis.cancel();\r\n\r\n    // Clean text\r\n    const cleanText = text\r\n      .replace(/```[\\s\\S]*?```/g, '')\r\n      .replace(/`[^`]*`/g, '')\r\n      .replace(/[#*_~]/g, '')\r\n      .trim();\r\n\r\n    if (!cleanText) return;\r\n\r\n    const utterance = new SpeechSynthesisUtterance(cleanText);\r\n    utterance.rate = 1.0;\r\n    utterance.pitch = 1.0;\r\n    utterance.volume = 1.0;\r\n\r\n    // Try to use a natural voice\r\n    const voices = window.speechSynthesis.getVoices();\r\n    const preferredVoice = voices.find(v =>\r\n      v.name.includes('Samantha') ||\r\n      v.name.includes('Google') ||\r\n      v.name.includes('Natural')\r\n    );\r\n\r\n    if (preferredVoice) {\r\n      utterance.voice = preferredVoice;\r\n    }\r\n\r\n    window.speechSynthesis.speak(utterance);\r\n  }, []);\r\n\r\n  const stopSpeaking = useCallback(() => {\r\n    if ('speechSynthesis' in window) {\r\n      window.speechSynthesis.cancel();\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    isRecording,\r\n    isProcessing,\r\n    error,\r\n    startRecording,\r\n    stopRecording,\r\n    speak,\r\n    stopSpeaking\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}